Provenant de imagelib: ImageBGRb, ImageLb, GraphicsEx, LoadImageFailedException, SaveImageFailedException

Description du flow
===================
source image, source mask, dest image (as files)
offset x, y
RGB, mask as bytes

load all files
check (input image size == input mask size)
verify mask
  - check que le mask fit dans la destination (bust la destination)
  - check que le mask contient uniquement les valeurs permises
  - check que la selection ne bleed pas sur les bordures (nord, sud, est, ouest)
créer une version des image (taille de l'image dest)
  - source qui est "collé" dans une image vide (clone simple) a l'offset
  - meme chose pour le mask ...
  - a faire dans une seule boucle.
Trouver l'image d'output en executant le solver de poisson
sauvegarder l'image

Solver de poisson
=================
on passe l'image dest., le mask et ... (voir etape 3)
convertir l'image RGB (byte-based) en float-based suivant un ratio sur 255 pour chaque channel (ie. rf = rb / 255, gf = gb / 255)
calculer le champ de gradient pour l'image source cloné trivialement (et stocker ou passer en param...)
**********
// ce code est stupide il perd du temps a calculer des pixels que l'on utilisera pas...
for (uint y = 0; y < h-1; y++) {
	for (uint x = 0; x < w-1; x++) {
	    // p est une cellule du champ de gradient (u, v sont les coords du vecteur en ce point)
	    // I est l'image source trivialement cloné
		p.u = I(x+1,y) - I(x,y);
		p.v = I(x,y+1) - I(x,y);
	}
}
**********
calculer le divergent du champ de gradient qu'on vient de calculer (pour finalement obtenir la matrice des laplaciens)
**********
for (uint y = 1; y < h; y++) {
	for (uint x = 1; x < w; x++) {
	   // p est une cellule dans la matrice des laplaciens
		T p = I(x,y).u - I(x-1,y).u +
			  I(x,y).v - I(x,y-1).v;
		O.setPixel(x,y,p);
	}
}
*********
Tout ça peut etre précaculé: ce sont les parametres envoyés au solver... (see below)
void Solver::solve(const ImageBGRf& Destination, const ImageLb& Mask, const ImageBGRf& divergents, ImageBGRf& Output)

Remplir un hashmap avec des clés étant la position linéarisée (id = y*w+x) 
avec des valeurs en partant de 0 à N (soit le nombre points dans la selection du mask) (incrémente pour chaque nouveau point de selection)

S'assurer que ce hashmap n'est pas vide (si c'est le cas, il n'y avait rien de vraiment sélectionné dans le masque)

Ceci implique de résoudre pour N pixels inconnus (3*N en comptant les channels)

Résoudre Ax = b avec les trois channels en même temps (haute concurrence sans dép., facilement parallèlisable ???)

Instanciation de la matrice creuse (appelé MAT ici) (sparse matrix) de N par N avec de l'espace pour 5*N éléments non nuls (matrice de réels de type Double)
JMP semble intéressant : http://www.uib.no/People/nmabh/jmp/index2.html

UBER PARALLELISABLE !!!!

initialiser n = 0
for(chaque pixel dans l'image destination) {
	s'il s'agit d'un pixel dans la sélection {
		uint id = y*w+x; // ID du hashmap courant (position linéarisée)
		extraire les 3 channels du pixel courant DANS LES DIVERGENTS (laplacien)
		
		pour les 4 voisins (check séquentiellement, pas necessairement une boucle)		
		// si le voisin du haut est en dehors de la selection (DIRICHLET BOUNDARY CONDITION)
		... (this is the tricky part... je ne la comprends pas à cause de l'API merdique de TAUCS)
				
		n++
	}
}

Assert n == N

transposer la matrice creuse

solve matrice transposé pour les N inconnus (3*N avec channels)
il semble que ce soit présenté en décomposition LU (lower uppper)

réécrire les pixels "inconnus" dans l'image destination (avec clamping de 0 à 1 au cas ou ça diverge ?!)

THAT's it !













